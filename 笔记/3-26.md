### 数组的方法：
#### 1.includes：
  * arr.includes(searchElement, fromIndex)
  * 一直以为只有一个参数，第二个参数可选，重该索引值查找前面的ele
  * fromIndex大于数组长度的时候 就返回false
  * includes 应用：

  ```
   var a=[2,3,4,7,9,33,322,3,4,444,3];
   var b=[3,2,7,4,6,12,3,9];
    
    //差集
    var c=a.concat(b);
    var dd=c.filter(v => !a.includes(v) || !b.includes(v) )

    console.log([...new Set(dd)])

    //数组去重 合并
    function combine(){ 
        let arr = [].concat.apply([], arguments);  //没有去重复的新数组 
        return Array.from(new Set(arr));
        } 

        var m = [1, 2, 2], n = [2,3,3]; 
        console.log(combine(m,n));  

        //其实我不是很明白上面的写
        var concatArr=m.concat(n);
        console.log(Array.from(new Set(arr)));
        //或者
        console.log([...new Set(arr)]);

  ```

  * 原来不太清楚new Set 数组去重为啥要和Arrary.from()结合使用，，原来也是转为数组的,从一个类似数组或可迭代对象中创建一个新的数组实例。
#### Arrary.from()
  * Array.from(arrayLike, mapFn, thisArg)
  * 返回一个数组实例
  * Array.from({length:10000},(v,i)=>{return i})  创建了一个数组长度为10000的数组，将伪类 数转化为数组；
  * 看到创建数组的方法，分析批量操作数组，，性能上的比较
  [http://www.jb51.net/article/109100.htm](http://www.jb51.net/article/109100.htm)
#### 搜索
* 搜索 find, findIndex, indexOf, lastIndexOf
* 返回从头开始第一个符合条件的元素 find
* 返回从头开始第一个符合条件的元素的索引号 findIndex
* 返回从头开始第一个特定元素的索引号 indexOf
* 返回从尾开始第一个特定元素的索引号 lastIndexOf

#### 
* 注意：every与some具有逻辑运算的短路性。 
* 在遍历的途中：

* every只要收到一个false，就会停止遍历；
* some只要收到一个true，就会停止遍历；

  
#### [数组原型上的方法分](https://blog.csdn.net/zccz14/article/details/51582718)
   
   * [https://blog.csdn.net/zccz14/article/details/51582718](https://blog.csdn.net/zccz14/article/details/51582718)

