# lyan
前端开发 一些基础 零碎的笔记
## 整理的笔记：
### map forEach 区别？
  * map 的回调函数中支持return 不影响原来的数组，相当于clone 一份；
  * forEach 按照顺序一个一个来具体怎么操作无所谓；forEach(当前项，当前位置，原始数组) forEach 方法中的this 是arr 回调函数中的this 默认是window
 * map() forEach() filter() reduce()  会跳过空位但是会保留这个值，join()和toString()会将空位视为undefined
### defer和async的区别？
  * 没有defer和async的时候，立即加载并执行指定的脚本
  * 相同：两者都是异步的；不同的是：它俩的差别在于脚本下载完之后何时执行
  * 因为浏览器在遇到script标签的时候，文档的解析会停止，不再构建document，有时打开一个网页上会出现空白一段时间，浏览器显示是刷新请求状态(也就是一直转圈)，这就会给用户很不好的体验，defer和async的合理使用就可以避免这个情况，而且通常script的位置建议写在页面底部(移动端应用的比较多，这两个都是html5中的新属性)。
  * 没有这2个时候：文档解析停止，并立即下载并执行脚本
  * async模式：文档解析不会停止，其他线程将下载脚本，脚本下载完成后开始执行脚本，async 则是一个乱序执行的主
  * defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本的执行需要等到文档所有元素解析完成之后，DOMContentLoaded事件触发执行之前。

### document.ready和onload的区别?
  * 一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件）
  * 二是onload，指示页面包含图片等文件在内的所有元素都加载完成。
  * $(function(){}) 这个其实就是jq ready（）的简写
  * 一般情况下 页面响应的顺序是，域名解析》加载html》加载js和css》加载图片等其他的信息
  * window.onload=function(){//do }
  * Dom Ready是在dom加载完成后就可以直接对dom进行操作，比如一张图片只要<img>标签完成，不用等这个图片加载完成，就可以设置图片的宽高的属性或样式等；
Dom Load是在整个document文档（包括了加载图片等其他信息）加载完成后就可以直接对dom进行操作，比如一张图片要等这个图标加载完成之后才能设置图片的宽高的属性或样式等；
比如一个图片浏览的效果，通常如果图片尺寸很大的情况下，为了防止图片把页面撑开通常会限定图片的宽度或高度，如果是单张图片或者是多张规格比例统一的图片下我们可以直接在<img>上价格宽度或者高度的属性<img src=“img.jpg” alt=”码头的大照片” width=“100” height=“90”>，比如（推荐）或者可以在css样式中加宽度或者高度的属性。但是如果这些张规格比例不统一的图片要浏览呢？那就有问题，你设置宽高很可能造成图片严重失真。在ie6之后ie7，ie8还有其他主流浏览器支持css2.1中min-width，max-width，min-height，max-width，这样我们就可以用min-width，max-width，min-height，max-width解决这些问题，但是ie6除非是抛弃性能问题用css表达式（当然old9(http://old9.blogsome.com/2008/10/26/css-expression-reloaded/)和怿飞(http://www.planabc.net/2009/09/21/optimization_of_css_eexpression/)有关于css表达式性能问题的解决方案,大家可以看一下）。这个时候ie的做好解决方案就是用Dom Ready而不是Dom Load，因为通常大图片加载的时候会一点一点的加载，这个在尺寸大，字节多，网速慢的时候表现的非常明显，用Dom Load，通常是先把页面撑开，加载完成后再把图片重设宽高，图片加载多少时间，这个页面就会撑开多久，用户会非常难受！！
这点可以看我做的一个的一个小demo：http://www.css88.com/demo/domready/(注意第二次测试的时候要清除缓存)
### 创建函数的几种方式：
   * 声明函数；
   * 创建匿名函数表达式；
   * 创建具名函数表达式
   * function 构造函数；
   * 自执行函数；
### 数组常用的方法：
   * shift() 删除数组的第一项，返回删除项；如果数组为空则返回undefined；改变原来的数组； 
   * unshift() 相反，添加到数组的开头；返回的是添加之后数组的长度，也是改变数组的操作；
   * pop() 删除最后一项，返回删除的项
   * push() 从数组的尾部添加，返回的是数组的长度；
   * join() 将数组元素 组起成一个字符串，中间是分割符号；
   * sort() 排序 从小到大 实际上比较的也是字符串，因此会出现不准确； 为了解决可以接收一个比较函数，元数组也是会改变的
   * reverse()  反转数组的顺序
   * concat()  将参数添加到原数组中。这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给 concat()方法传递参数的情况下，它只是复制当前数组并返回副本
   * splice()
       * 很强大的数组方法，它有很多种用法，可以实现删除、插入和替换。
       
      * 删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如， splice(0,2)会删除数组中的前两项。
         插入：可以向指定位置插入任意数量的项，只需提供 3 个参数：起始位置、 0（要删除的项数）和要插入的项。例如，splice(2,0,4,6)会从当前数组的位置 2 开始插入4和6。
       *  替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,4,6)会删除当前数组位置 2 的项，然后再从位置 2 开始插入4和6。


      > splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项，如果没有删除任何项，则返回一个空数组。


   * slice()  返回从原数组中指定开始下标到结束下标之间的项组成的新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下， slice()方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数，该方法返回起始和结束位置之间的项——但不包括结束位置的项； 注意：原来的数组没有改变
   * indexOf() lasteIndexOf() :
    >  接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中， 从数组的开头（位置 0）开始向后查找。
   * forEach()
   * map()
   * filter()
   * every()  判断数组中每一项都是否满足条件，只有所有项都满足条件，才会返回true。
   * reduce()
   > 这两个方法都会实现迭代数组的所有项，然后构建一个最终返回的值;传给 reduce()和 reduceRight()的函数接收 4 个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。

 
